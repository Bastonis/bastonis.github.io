<!DOCTYPE html>
<head>
  <title>Bastonis | Object Oriented Style</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../default.css">
  <link rel="stylesheet" type="text/css" href="../blog/blog-stylesheet.css">
  <link href='http://fonts.googleapis.com/css?family=Merriweather|Kaushan+Script' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
</head>
<nav class="navbar">
  <ul>
    <li><a href="../../index">Home</a></li>
    <li><a href="../../about-me">About Me</a></li>
    <li><a href="#">Portfolio</a></li>
    <li><a href="../blog/blog-home">My Blog</a></li>
  </ul>
</nav>
</nav>
<main>
  <h1 class="header">Object Oriented vs Functional Programming</h1>
  <h2 class="header"><!--Subtitle--></h2>
  <h4 class="header">May 17, 2015</h4>

  <section>
    <p>
      I had only heard whispers of the different programming paradigms when I first started, and given the nature of learning Ruby, I thought it would really be beneficial to tackle the differences between Object Oriented Programing (OOP)vs Functional Programming (FP). 
    </p>
    <p>
      Object Oriented Programming is based around the creation of objects, which have attributes, and can perform different procedures, called methods. With OOP, programs are designed by creating objects that interact with other objects in order to fulfill the desired execution. Functional Programming, on the other hand, computes functions and avoids dealing with changing-state and mutable data, which is data that can be modified after creation. Functional coding outputs code that depends on the arguments that are inputted.
    </p>
    <p> 
      While searching up ways to explain OOP, Steve Jobs has succinctly answered this in an <a href = "http://www.rollingstone.com/culture/news/steve-jobs-in-1994-the-rolling-stone-interview-20110117">interview</a> in Rolling Stone magazine in 2011 where he states: 
    </p>
    <p>
      Objects are like people. They're living, breathing things that have knowledge inside them about how to do things and have memory inside them so they can remember things. And rather than interacting with them at a very low level, you interact with them at a very high level of abstraction, like we're doing right here.
      Here's an example: If I'm your laundry object, you can give me your dirty clothes and send me a message that says, "Can you get my clothes laundered, please." I happen to know where the best laundry place in San Francisco is. And I speak English, and I have dollars in my pockets. So I go out and hail a taxicab and tell the driver to take me to this place in San Francisco. I go get your clothes laundered, I jump back in the cab, I get back here. I give you your clean clothes and say, "Here are your clean clothes."
      You have no idea how I did that. You have no knowledge of the laundry place. Maybe you speak French, and you can't even hail a taxi. You can't pay for one, you don't have dollars in your pocket. Yet I knew how to do all of that. And you didn't have to know any of it. All that complexity was hidden inside of me, and we were able to interact at a very high level of abstraction. That's what objects are. They encapsulate complexity, and the interfaces to that complexity are high level.
    </p>
    <p>
      OOP knows that data and the operations tied to it are closely related. An object knows itself and the operations it can perform. It can hide some of these functions from other objects, just like the laundry object in Jobs' example. OOP focused around creating new objects and evolving existing objects by creating new methods that it can do. 
    </p>
    <p>
      FP believes that data is not as tightly related to the functions. The function is the key point within FP, not the data. Functions do one thing and one thing only. To look at these two paradigms, OOP focuses on data first, methods/functions/code second; FP focuses on the function first and the data second. 
    </p>
    <p>
      Due to their inherence preferences, problems occur in both OOP and FP when trying to evolve your code. For OOP, creating a new operation may require you to go back to different classes, their definition, and create new methods in order for the operation to work. For FP, multiple function definitions may be required in order to create a new case. 
    </p>
    <p>
      While this may be simplistic in nature, I found that weaving through the differences between OOP and FP, the core tenets are complementary in ideology. However, when going into its usage and which one is "better", this can get into a fiery debate online. Hope this cleared up the fundamental differences between FP and OOP!
    </p>
  </section>
  <div id="page_nav">
    <a href="../blog/c5-feedback">Previous</a>
    <a href="../blog/c6-stereotype-threat">Next</a>
  </div>
</main>
<section id = "social-media">
  <a href="https://github.com/bastonis">
    <i class="fa fa-github fa-lg"></i>
  </a>
  <a href="https://twitter.com/bastonis_">
    <i class="fa fa-twitter fa-lg"></i>
  </a>
  <a href="https://www.linkedin.com/in/ryanlau92">
    <i class="fa fa-linkedin fa-lg"></i>
  </a>
</section>
